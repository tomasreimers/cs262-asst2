[March 6, 2016]
 - First idea is to implement each of the VMs as a thread with an associated
   global message queue (that other threads can append to) and a lock.
    - Each thread could run in a 'while True' and sleep for the appropriate
      amount of seconds at the end of the cycle
    - We would need some way to synchronize the threads to all start at the same
      time, we could create a global barrier sync mechanism that is initialized
      with some n, and waits until n calls to barrier.wait() have been made
      (where each call is blocking until n is reached)
 - The assignment says we need to use 'network sockets' to pass messages. Asking
   on piazza if this is a strict requirement.
   https://canvas.harvard.edu/courses/9563/discussion_topics/104698
 - Googling around, found that Python already provides a Barrier synchronization
   object (https://docs.python.org/3/library/threading.html)
 - Rereading instructions, turns out way we throttle machines is:
     "Each machine will run at a clock rate determined during initialization.
      You will pick a random number between 1 and 6, and that will be the number
      of clock ticks per second for that machine"
   Ugh, back to the drawing board. We could store the last time it ran, and how
   many instructions it ran.
    - Hmm, what if we fudge it and make each instruction take 1/clock_speed
      seconds, this would ensure that only clock_speed instructions happen in a
      second. And we could even time instructions so that we only block for
      1/clock_speed - actual_time_taken.
       - Good call, going forward with this. Will also be more realistic. Also
         because we're threading, if you get switched in middle or instruction,
         will not add extra execution time, so will seem like we're actually
         simulating multiple cores.
 - Almost done! (Well with code, god knows how long debugging will take).
   Reading through notes I realize that I'm not sure if we update the LC before/
   after the message send. Adding a TODO.
 - Ah, so python doesn't actually have barrier ("New in version 3.2.")
    - Wait! It's in the multiprocessing library
       - Nope. It is not there for 2.7 either
          - A Barrier may be overkill (esp b/c we do no initialization in the
            thread). Removing for now, and will add a TODO to investigate if
            necessary.
 - Very difficult to kill multithreaded py program (ctrl-c doesn't work),
   googling for solution.
    - Solution found! Can set to Daemons and *not* join to them
      http://stackoverflow.com/questions/1635080/terminate-a-multi-thread-python-program
 - Okay, looks like it's working... Will need more tests.
    - Cool stuff! Observing that on slower systems, the queue accumulates and
      then the LC falls behind.

- small changes to observe procesor speeds of vms and which process VMs send messages to WX
